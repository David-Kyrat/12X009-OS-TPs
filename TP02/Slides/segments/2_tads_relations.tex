\section{TADs \& leurs relations}
\subsection{Décomposition modulaire}
\bframe{

\setbeamertemplate{itemize items}[circle]
\begin{itemize}
\item First item.
\item Second item.
\item Third item.
\end{itemize}
}


\begin{frame}{\sn : \ssn}
%

TP reste assez simple, seulement 2 modules ont été créés.\\ Le premier \code{OptionParser} (qui, part la suite, sera le début d'un module \code{util} qui sera réutilisé et aggrandi à chaque TP suivant) qui s'occupe de vérifier si l'input de l'utilisateur est valide ou pas, \textit{sépare}, \textit{copie} et \textit{stoque} les différentes parties des différentes entrées en fonctions des options de ces dernières.\\


\vspace{0.5cm}
Le second \code{hash\_calc} qui s'occupe de gérer les \quo{digest context}, i.e. les créer, y rajouter du text à hash\ldots \(\, \)
ces contexts sont une interface qui va permettre d'ajouter différents message à la suite puis d'en hash le tout uniqument lorsqu'on
décide de le terminer.

\end{frame}

\bframes{
    Par exemple \code{OptionParser} contient une fonction \code{checkEnoughArgs()}  (dont le nom est déjà assez explicite), ainsi qu'une autre fonction \code{\scriptsize  int parseArgs(int argc, char* argv[], char** fileToHash[], }\\
    \indent $\quad$ \code{\scriptsize int* fileAmnt, char** stringToHash   )}
    qui va :
    \begin{itemize}
        \item parse les arguments optionnels\\
        \vspace{0.1cm}
        
        \item Si \code{-f} n'as \textit{pas} été fourni $\Rightarrow$ appel une fonction plus simple pour juste hash la concaténation des entrées avec la méthode donnée avec \code{-t}. i.e. va stocker la concaténation dans 
        \code{stringToHash}.\\
        \vspace{0.1cm}
        
        \item Si \code{-f} a été fourni, va extraire chaque nom de fichier et les stocker dans le buffer \code{fileToHash}.
        \vspace{0.1cm}
        
    \end{itemize}
}

\bframes{
    \code{hash\_calc}, quant à lui, contient une fonction \code{convert\_f\_to\_s()} qui extrait le contenu d'un fichier pour pouvoir passer le contenu
    directement à la fonction \code{hash()}. L'implémentation de \code{convert\_f\_to\_s()} a été repris du tp sur ultra-cp qui est elle-même fortement inspirée
    des slides du cours. i.e. implémentation manuelle \quo{bufferisé} de lecture de fichier avec \code{read()}.
}

%!! METTRE çA QQ PART POUR LAVOIR A LEXAMEN !!

%/**
 %* Call parseOptArgs to parse given ptions then if "-f" was not provided, 
 %* call parseArgsAsString to interpret all given argument (that are not options) as 1 single string
 %* i.e. "-f file1 file2 [-t <hashMethod>]" parses file1, file2 and hashMethod as separate %things to hash.
 %* and "s1 s2 [-t <hashMethod>]" parses "s1 s2" as 1 string to hash.
 %* 
 %* @param argc Number of arguments passed to the program.
 %* @param argv Array of arguments given to the program.
 %* @param givenFilesToHash pointer to string array into which store the parsed files to hash or null if -f was not provided. Does a malloc. Remember to free! (when according option was chosen)
 %* @param fileAmnt Variable into which store the amount of given files.
 %* @param givenStringToHash pointer to string into which store the parsed string to hash or null if -f was provided. Does a malloc. Remember to free! (when according option was chosen)
 %* @return 0 if success else error code
 %*/


%

\subsection{Structures de données utilisées}
\bframe{
    L'implémentation de structure n'a pas été nécessaire.
}

%
%
